<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–®–∞—Ö—Ç—ë—Ä: –î–æ–±—ã—á–∞ –†–µ–¥–∫–∏—Ö –ú–µ—Ç–∞–ª–ª–æ–≤</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; padding: 0; font-family: 'Arial', sans-serif; background: linear-gradient(to bottom, #001122, #000011); color: white; overflow: hidden; user-select: none; -webkit-user-select: none; touch-action: manipulation; }
        #game { display: flex; flex-direction: column; height: 100vh; max-width: 100vw; }
        #canvas { flex: 1; background: #111; border-bottom: 2px solid #333; touch-action: none; }
        #ui { padding: 10px; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; gap: 10px; }
        .stat { display: flex; justify-content: space-between; font-size: 18px; font-weight: bold; }
        #digBtn { background: linear-gradient(45deg, #ffaa00, #ff6600); border: none; border-radius: 15px; font-size: 24px; font-weight: bold; padding: 20px; color: white; cursor: pointer; user-select: none; transition: all 0.1s; box-shadow: 0 5px 15px rgba(255,170,0,0.5); }
        #digBtn:active { transform: scale(0.95); box-shadow: 0 2px 5px rgba(255,170,0,0.3); }
        #shop { display: flex; gap: 10px; flex-wrap: wrap; }
        .upgrade { background: rgba(0,255,0,0.2); border: 2px solid #00ff00; border-radius: 10px; padding: 10px; flex: 1; min-width: 120px; text-align: center; cursor: pointer; transition: all 0.2s; }
        .upgrade.afford { background: rgba(0,255,0,0.4); }
        .upgrade:not(.afford) { opacity: 0.5; cursor: not-allowed; }
        .upgrade:active { transform: scale(0.98); }
        .price { color: #ffd700; font-weight: bold; }
        #message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 32px; font-weight: bold; color: #ffd700; pointer-events: none; opacity: 0; transition: opacity 0.5s; text-shadow: 2px 2px 4px #000; z-index: 10; }
        .ore { position: absolute; font-size: 40px; pointer-events: none; opacity: 0; transition: all 1s; z-index: 5; }
    </style>
</head>
<body>
    <div id="game">
        <canvas id="canvas"></canvas>
        <div id="ui">
            <div class="stat"><span>üí∞ –ú–æ–Ω–µ—Ç—ã:</span><span id="coins">0</span></div>
            <div class="stat"><span>‚õèÔ∏è –ì–ª—É–±–∏–Ω–∞:</span><span id="depth">1–º</span></div>
            <div class="stat"><span>‚ö° –°–∫–æ—Ä–æ—Å—Ç—å:</span><span id="speed">1/—Å</span></div>
            <button id="digBtn">‚õèÔ∏è –ö–û–ü–ê–¢–¨! ‚õèÔ∏è</button>
            <div id="shop">
                <div class="upgrade" data-type="pickaxe"><div>–ö–∏—Ä–ø–∏—á +1</div><div class="price" data-price="50">50üí∞</div></div>
                <div class="upgrade" data-type="auto"><div>–ê–≤—Ç–æ-–∫–æ–ø–∞—Ç–µ–ª—å</div><div class="price" data-price="200">200üí∞</div></div>
                <div class="upgrade" data-type="depth"><div>–ì–ª—É–±–∂–µ!</div><div class="price" data-price="1000">1000üí∞</div></div>
            </div>
        </div>
        <div id="message"></div>
    </div>

    <script>
        let tg = window.Telegram.WebApp;
        tg.ready(); tg.expand();

        let game = { coins: 0, depth: 1, pickaxePower: 1, autoMiners: 0, autoPower: 1, lastTime: 0, saveInterval: 0 };

        const ores = [
            { name: 'ü™®', value: 1, minDepth: 1, chance: 0.8 },
            { name: 'üî©', value: 5, minDepth: 5, chance: 0.5 },
            { name: 'ü•â', value: 20, minDepth: 20, chance: 0.3 },
            { name: '‚≠ê', value: 100, minDepth: 50, chance: 0.15 },
            { name: 'üíé', value: 500, minDepth: 100, chance: 0.05 }
        ];

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        function resizeCanvas() { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; }
        window.addEventListener('resize', resizeCanvas); resizeCanvas();

        // –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —á–∏—Å–µ–ª
        function formatNumber(num) {
            if (num < 1000) return Math.floor(num).toLocaleString();
            const units = ['', 'k', 'M', 'B', 'T'];
            let i = 0;
            while (num >= 1000 && i < units.length - 1) { num /= 1000; i++; }
            return num.toFixed(2).replace(/\.00$/, '') + units[i];
        }

        function formatDepth(meters) {
            if (meters < 1000) return Math.floor(meters) + '–º';
            const units = ['–∫–º', '–ú–º', '–ì–º', '–¢–º'];
            let val = meters / 1000;
            let i = 0;
            while (val >= 1000 && i < units.length - 1) { val /= 1000; i++; }
            return val.toFixed(2).replace(/\.00$/, '') + ' ' + units[i];
        }

        async function loadGame() {
            try {
                const data = await tg.CloudStorage.getItems(['gameSave']);
                if (data['gameSave']) Object.assign(game, JSON.parse(data['gameSave']));
            } catch (e) {
                const local = localStorage.getItem('minerSave');
                if (local) Object.assign(game, JSON.parse(local));
            }
        }

        async function saveGame() {
            try { await tg.CloudStorage.setItem('gameSave', JSON.stringify(game)); }
            catch (e) { localStorage.setItem('minerSave', JSON.stringify(game)); }
        }

        function getOre() {
            const rand = Math.random();
            let cumulative = 0;
            for (let ore of ores) {
                if (game.depth >= ore.minDepth) {
                    cumulative += ore.chance * (1 + (game.depth - ore.minDepth) / 1000);
                    if (rand < cumulative) return ore;
                }
            }
            return ores[0];
        }

        function showOre(x, y, ore) {
            const elem = document.createElement('div');
            elem.className = 'ore'; elem.innerHTML = ore.name;
            elem.style.left = x + 'px'; elem.style.top = y + 'px';
            document.body.appendChild(elem);
            setTimeout(() => { elem.style.opacity = '1'; elem.style.transform = 'translateY(-50px) scale(1.2)'; }, 10);
            setTimeout(() => elem.remove(), 1000);
        }

        function drawMine() {
            ctx.fillStyle = '#111'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333'; ctx.fillRect(0, 0, 50, canvas.height); ctx.fillRect(canvas.width - 50, 0, 50, canvas.height);

            const blockHeight = 30;
            const blocks = Math.ceil(canvas.height / blockHeight);
            for (let i = 0; i < blocks; i++) {
                const depthHere = game.depth - blocks + i + 1;
                ctx.fillStyle = depthHere > 0 ? '#8B4513' : '#654321';
                ctx.fillRect(50, i * blockHeight, canvas.width - 100, blockHeight);
                if (Math.random() < 0.1 && depthHere > 10) {
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(60 + Math.random() * (canvas.width - 140), i * blockHeight + 5, 20, 20);
                }
            }

            // –®–∞—Ö—Ç—ë—Ä
            ctx.fillStyle = '#FFDBAC'; ctx.beginPath(); ctx.arc(canvas.width / 2, canvas.height - 40, 20, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#000'; ctx.fillRect(canvas.width / 2 - 5, canvas.height - 50, 10, 20);
            ctx.fillStyle = '#FFD700'; ctx.fillRect(canvas.width / 2 - 15, canvas.height - 45, 30, 10);

            ctx.fillStyle = '#FFF'; ctx.font = '24px Arial'; ctx.textAlign = 'center';
            ctx.fillText(`–ì–ª—É–±–∏–Ω–∞: ${formatDepth(game.depth)}`, canvas.width / 2, 40);
        }

        function dig() {
            const ore = getOre();
            const amount = game.pickaxePower * (1 + Math.floor(game.depth / 10));
            game.coins += ore.value * amount;
            showOre(canvas.width / 2 - 20, canvas.height - 100, ore);
            showMessage(`+${formatNumber(ore.value * amount)} üí∞`);
            updateUI();
        }

        function autoDig(dt) {
            const autoEarn = game.autoMiners * game.autoPower * dt * (1 + game.depth / 100);
            game.coins += Math.floor(autoEarn);
        }

        function showMessage(text) {
            const msg = document.getElementById('message');
            msg.textContent = text; msg.style.opacity = '1';
            setTimeout(() => msg.style.opacity = '0', 1000);
        }

        function updateUI() {
            document.getElementById('coins').textContent = formatNumber(game.coins);
            document.getElementById('depth').textContent = formatDepth(game.depth);
            document.getElementById('speed').textContent = (game.pickaxePower + game.autoMiners * game.autoPower).toFixed(1) + '/—Å';

            document.querySelectorAll('.upgrade').forEach(up => {
                const type = up.dataset.type;
                let price = 0;
                if (type === 'pickaxe') price = 50 * Math.pow(1.5, game.pickaxePower);
                else if (type === 'auto') price = 200 * Math.pow(2, game.autoMiners);
                else if (type === 'depth') price = 1000 * Math.pow(1.3, Math.floor(game.depth / 10));
                up.querySelector('.price').textContent = formatNumber(Math.floor(price)) + 'üí∞';
                if (game.coins >= price) up.classList.add('afford');
                else up.classList.remove('afford');
            });
        }

        document.querySelectorAll('.upgrade').forEach(up => {
            up.addEventListener('click', () => {
                const type = up.dataset.type;
                let price = 0;
                if (type === 'pickaxe') {
                    price = 50 * Math.pow(1.5, game.pickaxePower);
                    if (game.coins >= price) { game.coins -= price; game.pickaxePower++; showMessage('üõ†Ô∏è –ö–∏—Ä–ø–∏—á —É–ª—É—á—à–µ–Ω!'); }
                } else if (type === 'auto') {
                    price = 200 * Math.pow(2, game.autoMiners);
                    if (game.coins >= price) { game.coins -= price; game.autoMiners++; game.autoPower += 0.5; showMessage('ü§ñ –ê–≤—Ç–æ-–∫–æ–ø–∞—Ç–µ–ª—å!'); }
                } else if (type === 'depth') {
                    price = 1000 * Math.pow(1.3, Math.floor(game.depth / 10));
                    if (game.coins >= price) { game.coins -= price; game.depth += 10; showMessage('‚¨áÔ∏è –°–ø—É—Å—Ç–∏–ª—Å—è –≥–ª—É–±–∂–µ!'); }
                }
                updateUI();
            });
        });

        function gameLoop(now) {
            const dt = (now - game.lastTime) / 1000 || 0;
            game.lastTime = now;
            autoDig(dt);
            game.depth += dt * 0.1;
            game.saveInterval += dt;
            if (game.saveInterval > 10) { saveGame(); game.saveInterval = 0; }
            drawMine();
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        document.getElementById('digBtn').addEventListener('click', dig);
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            if (x > 50 && x < canvas.width - 50) dig();
        });

        loadGame().then(() => {
            updateUI();
            game.lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
